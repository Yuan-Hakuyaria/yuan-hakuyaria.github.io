<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº¤äº’å¼ç²’å­é»‘æ´/ç™½æ´</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        #configBtn, #infoBtn, #toggleHoleBtn {
            position: fixed;
            top: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 200;
            backdrop-filter: blur(10px);
            transition: background 0.3s;
        }
        #configBtn {
            right: 130px;
        }
        #toggleHoleBtn {
            right: 70px;
        }
        #infoBtn {
            right: 10px;
        }
        #configBtn:hover, #infoBtn:hover, #toggleHoleBtn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 300;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #1a1a1a;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            color: white;
            font-family: Arial, sans-serif;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .modal-content h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #ff4500;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }
        .warning-label {
            color: #ff4500;
            font-size: 0.9em;
            margin-top: 5px;
        }
        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 5px;
            background: #2a2a2a;
            color: white;
            box-sizing: border-box;
        }
        .form-group input:focus {
            outline: none;
            border-color: #ff4500;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        .btn-apply {
            background: #ff4500;
            color: white;
        }
        .btn-apply:hover {
            background: #ff6347;
        }
        .btn-close {
            background: #555;
            color: white;
        }
        .btn-close:hover {
            background: #666;
        }
        .btn-yes {
            background: #4CAF50;
            color: white;
        }
        .btn-yes:hover {
            background: #45a049;
        }
        .btn-no {
            background: #f44336;
            color: white;
        }
        .btn-no:hover {
            background: #da190b;
        }
        .info-text {
            font-size: 14px;
            line-height: 1.5;
            color: #ddd;
        }
        .info-text h3 {
            color: #ff4500;
            margin-top: 20px;
        }
        /* åŠ è½½é¡µé¢æ ·å¼ */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: Arial, sans-serif;
            flex-direction: column;
        }
        #loadingText {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ff4500;
        }
        #progressBar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        #progressFill {
            height: 100%;
            background: #ff4500;
            width: 0%;
            transition: width 0.3s;
        }
        /* æ¶ˆæ¯å¼¹çª—æ ·å¼ */
        #messageModal {
            display: none;
            position: fixed;
            z-index: 400;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
        }
        #messageContent {
            background-color: #1a1a1a;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 10px;
            width: 90%;
            max-width: 300px;
            color: white;
            font-family: Arial, sans-serif;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            text-align: center;
        }
        #messageText {
            margin-bottom: 15px;
            color: #ddd;
        }
        .btn-ok {
            background: #ff4500;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .btn-ok:hover {
            background: #ff6347;
        }
        /* ç¡®è®¤å¼¹çª—æ ·å¼ */
        #confirmModal {
            display: none;
            position: fixed;
            z-index: 400;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
        }
        #confirmContent {
            background-color: #1a1a1a;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 10px;
            width: 90%;
            max-width: 300px;
            color: white;
            font-family: Arial, sans-serif;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            text-align: center;
        }
        #confirmText {
            margin-bottom: 15px;
            color: #ddd;
        }
        #confirmTitle {
            color: #ff4500;
            margin-bottom: 10px;
        }
        .confirm-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        @media (max-width: 600px) {
            .modal-content {
                width: 95%;
                padding: 15px;
            }
            .modal-buttons {
                flex-direction: column;
            }
            .btn {
                margin-bottom: 10px;
            }
            #progressBar {
                width: 250px;
            }
            #messageContent, #confirmContent {
                width: 95%;
                padding: 15px;
            }
            .confirm-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- åŠ è½½é¡µé¢ -->
    <div id="loadingScreen">
        <div id="loadingText">ç²’å­ç”Ÿæˆä¸­â€¦â€¦</div>
        <div id="progressBar">
            <div id="progressFill"></div>
        </div>
        <div id="progressText" style="margin-top: 10px; font-size: 16px;">(0%/100%)</div>
    </div>
    <div id="info">é¼ æ ‡å·¦å³é”®æ—‹è½¬ç§»åŠ¨ æ»šè½®ç¼©æ”¾ ç‚¹å‡»å±å¹•ç”Ÿæˆç²’å­</div>
    <button id="configBtn">âš™ï¸</button>
    <button id="toggleHoleBtn">ğŸ”„</button>
    <button id="infoBtn">â”</button>
    <div id="configPanel" class="modal">
        <div class="modal-content">
            <h2 id="configTitle">é»‘æ´é…ç½®</h2>
            <form id="configForm">
                <!-- é»‘æ´å‚æ•° -->
                <div id="blackHoleParams" class="hole-params">
                    <div class="form-group">
                        <label for="growthSize">é»‘æ´æ¯çº§å¢é•¿å¤§å° (é»˜è®¤ 1):</label>
                        <input type="number" id="growthSize" placeholder="1" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="gravityInc">æ¯çº§å¸å¼•åŠ›å¢åŠ  (é»˜è®¤ 1):</label>
                        <input type="number" id="gravityInc" placeholder="1" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="initialCount">åˆå§‹ç²’å­æ•°é‡ (é»˜è®¤5000):</label>
                        <input type="number" id="initialCount" placeholder="5000" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="pushForce">ç™½è‰²ç²’å­æ¨åŠ› (é»˜è®¤1):</label>
                        <label class="warning-label">* æ•°å€¼å¤§æ€§èƒ½ä¸å¥½çš„è®¾å¤‡å®¹æ˜“å¡æ­»</label>
                        <input type="number" id="pushForce" placeholder="1" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="growthNum">ç™½è‰²ç²’å­æ•°é‡ (é»˜è®¤200):</label>
                        <label class="warning-label">* æ•°å€¼å¤§æ€§èƒ½ä¸å¥½çš„è®¾å¤‡å®¹æ˜“å¡æ­»</label>
                        <input type="number" id="growthNum" placeholder="200" min="0" step="1">
                    </div>
                </div>
                <!-- ç™½æ´å‚æ•° -->
                <div id="whiteHoleParams" class="hole-params" style="display: none;">
                    <div class="form-group">
                        <label for="ejectionSize">ç™½æ´æ¯çº§å–·å‡ºå¤§å° (é»˜è®¤ 1):</label>
                        <input type="number" id="ejectionSize" placeholder="1" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="repulsionInc">æ¯çº§æ’æ–¥åŠ›å¢åŠ  (é»˜è®¤ 1):</label>
                        <input type="number" id="repulsionInc" placeholder="1" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="initialEjectionCount">åˆå§‹å–·å‡ºç²’å­æ•°é‡ (é»˜è®¤5000):</label>
                        <input type="number" id="initialEjectionCount" placeholder="5000" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="pushForceWhite">å–·å‡ºç²’å­æ¨åŠ› (é»˜è®¤1):</label>
                        <label class="warning-label">* æ•°å€¼å¤§æ€§èƒ½ä¸å¥½çš„è®¾å¤‡å®¹æ˜“å¡æ­»</label>
                        <input type="number" id="pushForceWhite" placeholder="1" min="0" step="1">
                    </div>
                    <div class="form-group">
                        <label for="ejectionNum">å–·å‡ºç²’å­æ•°é‡ (é»˜è®¤200):</label>
                        <label class="warning-label">* æ•°å€¼å¤§æ€§èƒ½ä¸å¥½çš„è®¾å¤‡å®¹æ˜“å¡æ­»</label>
                        <input type="number" id="ejectionNum" placeholder="200" min="0" step="1">
                    </div>
                </div>
                <div class="modal-buttons">
                    <button type="button" class="btn btn-close" onclick="closeConfig()">å…³é—­</button>
                    <button type="button" class="btn btn-apply" onclick="applyConfig()">åº”ç”¨</button>
                </div>
            </form>
        </div>
    </div>
    <div id="gameInfoPanel" class="modal">
        <div class="modal-content">
            <h2>æ¸¸æˆä¿¡æ¯</h2>
            <div class="info-text">
                <h3>æ¸¸æˆç©æ³•</h3>
                <p>è¿™æ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿé»‘æ´/ç™½æ´ç²’å­å¸å¼•/æ’æ–¥çš„äº¤äº’å¼3Dè§†è§‰æ•ˆæœæ¸¸æˆã€‚ä½ å¯ä»¥ï¼š</p>
                <ul>
                    <li>æ‹–åŠ¨é¼ æ ‡æ—‹è½¬è§†è§’ï¼Œè§‚å¯Ÿé»‘æ´/ç™½æ´åŠå…¶å‘¨å›´ç¯å¢ƒã€‚</li>
                    <li>ç‚¹å‡»å±å¹•ä»»æ„ä½ç½®ç”Ÿæˆæ–°ç²’å­ï¼Œè¿™äº›ç²’å­ä¼šå—åˆ°é»‘æ´å¼•åŠ›æˆ–ç™½æ´æ’æ–¥çš„å½±å“ã€‚</li>
                    <li>ç²’å­æ¥è¿‘äº‹ä»¶è§†ç•Œæ—¶ä¼šå˜çº¢ï¼ˆé»‘æ´ï¼‰æˆ–å˜è“ï¼ˆç™½æ´ï¼‰ï¼Œå¹¶å¯èƒ½è¢«æ•è·æˆ–å–·å‡ºã€‚</li>
                    <li>å½“â€œå¸æ”¶â€æˆ–â€œå–·å‡ºâ€è¶³å¤Ÿç²’å­åï¼Œæ´ä¼šæˆé•¿ï¼Œå¢åŠ å¤§å°å’ŒåŠ›å¼ºåº¦ï¼Œä¼´éšç²’å­çˆ†å‘æ•ˆæœã€‚</li>
                    <li>ç¯ç»•ç²’å­æ¨¡æ‹Ÿå¸ç§¯ç›˜ï¼Œå½“ç²’å­æ•°é‡è¿‡å¤šæ—¶ä¼šç”©é£éƒ¨åˆ†ç²’å­ï¼Œé˜²æ­¢è®¾å¤‡å¡æ­»ã€‚</li>
                    <li>é…ç½®æŒ‰é’®å¯è°ƒæ•´æ¸¸æˆå‚æ•°ï¼Œåˆ‡æ¢æŒ‰é’®å¯åˆ‡æ¢é»‘æ´/ç™½æ´æ¨¡å¼ã€‚</li>
                    <li>æ¸©é¦¨æç¤ºï¼šç”µè„‘ç‰ˆä½“éªŒæ›´ä½³ã€‚</li>
                </ul>
                <h3>ä½œè€…ä¿¡æ¯</h3>
                <p>ä½œè€…ï¼šYuan<br>ç¨‹åºå‘˜ï¼šGrok 4<br>å…¶å®è¿™ä¸ªç½‘ç«™æ˜¯æ¥æµ‹è¯• Grok çš„ä»£ç ç¼–å†™èƒ½åŠ›çš„ï¼Œæˆ‘èŠ±äº†å‡ ä¸ªå°æ—¶çš„æˆæœå°±æ˜¯è¿™æ ·å­çš„</p>
            </div>
            <div class="modal-buttons">
                <button type="button" class="btn btn-close" onclick="closeGameInfo()">å…³é—­</button>
            </div>
        </div>
    </div>
    <!-- æ¶ˆæ¯å¼¹çª— -->
    <div id="messageModal" class="modal">
        <div id="messageContent">
            <div id="messageText"></div>
            <button class="btn-ok" onclick="closeMessage()">ç¡®å®š</button>
        </div>
    </div>
    <!-- ç¡®è®¤å¼¹çª— -->
    <div id="confirmModal" class="modal">
        <div id="confirmContent">
            <h3 id="confirmTitle">ç¡®è®¤åˆ‡æ¢</h3>
            <div id="confirmText"></div>
            <div class="confirm-buttons">
                <button class="btn btn-no" onclick="closeConfirm()">å¦</button>
                <button class="btn btn-yes" onclick="confirmSwitch()">æ˜¯</button>
            </div>
        </div>
    </div>
    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script>
        // æ´ç±»å‹
        let holeType = 'black'; // 'black' or 'white'
        // é»˜è®¤é…ç½®
        let config = {
            // é»‘æ´
            growthSize: 1,
            gravityInc: 1,
            initialParticleCount: 5000,
            pushForce: 1,
            growthNum: 200,
            // ç™½æ´
            ejectionSize: 1,
            repulsionInc: 1,
            initialEjectionCount: 5000,
            pushForceWhite: 1,
            ejectionNum: 200
        };
        let initialParticleCount = config.initialParticleCount;
        const clickParticleCount = 5;
        // åˆå§‹åŒ– Three.js åœºæ™¯
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        // æ·»åŠ è½¨é“æ§åˆ¶
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        // èƒŒæ™¯æ˜Ÿæ˜Ÿç³»ç»Ÿ
        const starCount = 2000;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const radius = 200 + Math.random() * 300;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            starPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            starPositions[i * 3 + 2] = radius * Math.cos(phi);
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        // ç¯ç»•ç²’å­ç³»ç»Ÿ
        let orbitCount = 2000;
        const orbitGeometry = new THREE.BufferGeometry();
        let orbitPositions = new Float32Array(orbitCount * 3);
        let orbitAngles = new Float32Array(orbitCount);
        let orbitRadii = new Float32Array(orbitCount);
        let targetOrbitRadii = new Float32Array(orbitCount);
        let orbitColors = new Float32Array(orbitCount * 3);
        let orbitTransitionActive = false;
        let orbitTransitionStartTime = 0;
        let blackHoleRadius = 4;
        const orbitMaterial = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });
        const orbitSystem = new THREE.Points(orbitGeometry, orbitMaterial);
        scene.add(orbitSystem);
        function initOrbit() {
            for (let i = 0; i < orbitCount; i++) {
                const radius = blackHoleRadius + 5 + Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                orbitRadii[i] = radius;
                targetOrbitRadii[i] = radius;
                orbitAngles[i] = theta;
                orbitPositions[i * 3] = radius * Math.cos(theta);
                orbitPositions[i * 3 + 1] = 0;
                orbitPositions[i * 3 + 2] = radius * Math.sin(theta);
                const color = new THREE.Color().setHSL(holeType === 'black' ? 0.1 : 0.6, 0.8, 0.5 + Math.random() * 0.3); // æ©™ for black, cyan for white
                orbitColors[i * 3] = color.r;
                orbitColors[i * 3 + 1] = color.g;
                orbitColors[i * 3 + 2] = color.b;
            }
            orbitGeometry.setAttribute('position', new THREE.BufferAttribute(orbitPositions, 3));
            orbitGeometry.setAttribute('color', new THREE.BufferAttribute(orbitColors, 3));
            orbitSystem.geometry.attributes.position.needsUpdate = true;
            orbitSystem.geometry.attributes.color.needsUpdate = true;
        }
        initOrbit();
        // ç”©é£ç²’å­ç³»ç»Ÿ
        let ejectAnimationActive = false;
        let ejectTimer = 0;
        let ejectParticles = null;
        let ejectVelocities = null;
        let ejectMaterial = null;
        let ejectCount = 0;
        function startEjectAnimation() {
            if (ejectAnimationActive) return;
            ejectAnimationActive = true;
            ejectTimer = 0;
            ejectCount = Math.floor(orbitCount * 0.4);
            const keepIndices = [];
            const ejectIndices = [];
            for (let i = 0; i < orbitCount; i++) {
                if (Math.random() < 0.4) {
                    ejectIndices.push(i);
                } else {
                    keepIndices.push(i);
                }
            }
            // å…ˆåˆ›å»ºç”©é£ç²’å­
            const ejectGeometry = new THREE.BufferGeometry();
            const ejectPositions = new Float32Array(ejectCount * 3);
            const ejectColors = new Float32Array(ejectCount * 3);
            ejectVelocities = new Float32Array(ejectCount * 3);
            let ejectIdx = 0;
            for (let i of ejectIndices) {
                ejectPositions[ejectIdx * 3] = orbitPositions[i * 3];
                ejectPositions[ejectIdx * 3 + 1] = orbitPositions[i * 3 + 1];
                ejectPositions[ejectIdx * 3 + 2] = orbitPositions[i * 3 + 2];
                ejectColors[ejectIdx * 3] = orbitColors[i * 3];
                ejectColors[ejectIdx * 3 + 1] = orbitColors[i * 3 + 1];
                ejectColors[ejectIdx * 3 + 2] = orbitColors[i * 3 + 2];
                const speed = 2.0 + Math.random() * 1.0;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                ejectVelocities[ejectIdx * 3] = speed * Math.sin(phi) * Math.cos(theta);
                ejectVelocities[ejectIdx * 3 + 1] = speed * Math.sin(phi) * Math.sin(theta);
                ejectVelocities[ejectIdx * 3 + 2] = speed * Math.cos(phi);
                ejectIdx++;
            }
            ejectGeometry.setAttribute('position', new THREE.BufferAttribute(ejectPositions, 3));
            ejectGeometry.setAttribute('color', new THREE.BufferAttribute(ejectColors, 3));
            ejectMaterial = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            ejectParticles = new THREE.Points(ejectGeometry, ejectMaterial);
            scene.add(ejectParticles);
            // é‡å»ºorbit
            const newOrbitCount = orbitCount - ejectCount;
            const newOrbitPositions = new Float32Array(newOrbitCount * 3);
            const newOrbitAngles = new Float32Array(newOrbitCount);
            const newOrbitRadii = new Float32Array(newOrbitCount);
            const newTargetOrbitRadii = new Float32Array(newOrbitCount);
            const newOrbitColors = new Float32Array(newOrbitCount * 3);
            let keepIdx = 0;
            for (let i of keepIndices) {
                newOrbitPositions[keepIdx * 3] = orbitPositions[i * 3];
                newOrbitPositions[keepIdx * 3 + 1] = orbitPositions[i * 3 + 1];
                newOrbitPositions[keepIdx * 3 + 2] = orbitPositions[i * 3 + 2];
                newOrbitAngles[keepIdx] = orbitAngles[i];
                newOrbitRadii[keepIdx] = orbitRadii[i];
                newTargetOrbitRadii[keepIdx] = targetOrbitRadii[i];
                newOrbitColors[keepIdx * 3] = orbitColors[i * 3];
                newOrbitColors[keepIdx * 3 + 1] = orbitColors[i * 3 + 1];
                newOrbitColors[keepIdx * 3 + 2] = orbitColors[i * 3 + 2];
                keepIdx++;
            }
            orbitCount = newOrbitCount;
            orbitPositions = newOrbitPositions;
            orbitAngles = newOrbitAngles;
            orbitRadii = newOrbitRadii;
            targetOrbitRadii = newTargetOrbitRadii;
            orbitColors = newOrbitColors;
            orbitGeometry.setAttribute('position', new THREE.BufferAttribute(orbitPositions, 3));
            orbitGeometry.setAttribute('color', new THREE.BufferAttribute(orbitColors, 3));
            orbitSystem.geometry.attributes.position.needsUpdate = true;
            orbitSystem.geometry.attributes.color.needsUpdate = true;
        }
        // æ£€æŸ¥å¯†é›†åº¦
        function checkAndEjectIfDense() {
            const densityThreshold = 3000;
            if (orbitCount > densityThreshold && !ejectAnimationActive) {
                startEjectAnimation();
            }
        }
        // æ·»åŠ åˆ°ç¯ç»•
        function addToOrbit() {
            orbitCount++;
            const newOrbitPositions = new Float32Array(orbitCount * 3);
            const newOrbitAngles = new Float32Array(orbitCount);
            const newOrbitRadii = new Float32Array(orbitCount);
            const newTargetOrbitRadii = new Float32Array(orbitCount);
            const newOrbitColors = new Float32Array(orbitCount * 3);
            newOrbitPositions.set(orbitPositions);
            newOrbitAngles.set(orbitAngles);
            newOrbitRadii.set(orbitRadii);
            newTargetOrbitRadii.set(targetOrbitRadii);
            newOrbitColors.set(orbitColors);
            const newRadius = blackHoleRadius + 5 + Math.random() * 10;
            const newTheta = Math.random() * Math.PI * 2;
            newOrbitRadii[orbitCount - 1] = newRadius;
            newTargetOrbitRadii[orbitCount - 1] = newRadius;
            newOrbitAngles[orbitCount - 1] = newTheta;
            newOrbitPositions[(orbitCount - 1) * 3] = newRadius * Math.cos(newTheta);
            newOrbitPositions[(orbitCount - 1) * 3 + 1] = 0;
            newOrbitPositions[(orbitCount - 1) * 3 + 2] = newRadius * Math.sin(newTheta);
            const newColor = new THREE.Color().setHSL(holeType === 'black' ? 0.1 : 0.6, 0.8, 0.5 + Math.random() * 0.3);
            newOrbitColors[(orbitCount - 1) * 3] = newColor.r;
            newOrbitColors[(orbitCount - 1) * 3 + 1] = newColor.g;
            newOrbitColors[(orbitCount - 1) * 3 + 2] = newColor.b;
            orbitPositions = newOrbitPositions;
            orbitAngles = newOrbitAngles;
            orbitRadii = newOrbitRadii;
            targetOrbitRadii = newTargetOrbitRadii;
            orbitColors = newOrbitColors;
            orbitGeometry.setAttribute('position', new THREE.BufferAttribute(orbitPositions, 3));
            orbitGeometry.setAttribute('color', new THREE.BufferAttribute(orbitColors, 3));
            orbitSystem.geometry.attributes.position.needsUpdate = true;
            orbitSystem.geometry.attributes.color.needsUpdate = true;
        }
        // æ›´æ–°ç¯ç»•ç›®æ ‡
        function updateOrbitTargets(currentBlackRadius, targetBlackRadius) {
            for (let i = 0; i < orbitCount; i++) {
                targetOrbitRadii[i] = targetBlackRadius + (orbitRadii[i] - currentBlackRadius);
            }
            orbitTransitionActive = true;
            orbitTransitionStartTime = Date.now();
        }
        // åˆå§‹åŒ–ç²’å­
        function initParticles(count, showSuccess = false) {
            particleCount = count;
            positions = new Float32Array(particleCount * 3);
            velocities = new Float32Array(particleCount * 3);
            colors = new Float32Array(particleCount * 3);
            sizes = new Float32Array(particleCount);
            particles.dispose();
            particles = new THREE.BufferGeometry();
            document.getElementById('loadingScreen').style.display = 'flex';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = '(0%/100%)';
            const total = count;
            let current = 0;
            const interval = setInterval(() => {
                const batchSize = Math.min(100, total - current);
                for (let b = 0; b < batchSize; b++) {
                    const i = current + b;
                    if (i >= total) break;
                    const radius = 80 + Math.random() * 150;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    velocities[i * 3] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
                    const tang_speed = 0.8 * Math.sqrt(forceStrength / radius);
                    let perp_x = -positions[i * 3 + 1];
                    let perp_y = positions[i * 3];
                    let perp_z = 0;
                    const perp_len = Math.sqrt(perp_x * perp_x + perp_y * perp_y);
                    if (perp_len > 0.001) {
                        perp_x /= perp_len;
                        perp_y /= perp_len;
                    }
                    velocities[i * 3] += tang_speed * perp_x;
                    velocities[i * 3 + 1] += tang_speed * perp_y;
                    velocities[i * 3 + 2] += (Math.random() - 0.5) * tang_speed * 0.2;
                    if (holeType === 'white') {
                        // outward component for white hole
                        const outward = 0.5;
                        velocities[i * 3] += (positions[i * 3] / radius) * outward;
                        velocities[i * 3 + 1] += (positions[i * 3 + 1] / radius) * outward;
                        velocities[i * 3 + 2] += (positions[i * 3 + 2] / radius) * outward;
                    }
                    const color = new THREE.Color().setHSL(holeType === 'black' ? 0.6 : 0.55, 0.8, 0.5 + Math.random() * 0.3);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    sizes[i] = 0.3 + Math.random() * 0.4;
                }
                current += batchSize;
                const progress = Math.floor((current / total) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = `(${progress}%/100%)`;
                if (current >= total) {
                    clearInterval(interval);
                    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                    particleSystem.geometry.dispose();
                    particleSystem.geometry = particles;
                    document.getElementById('loadingScreen').style.display = 'none';
                    if (showSuccess) {
                        showMessage('é…ç½®å·²åº”ç”¨å¹¶é‡æ–°åŠ è½½ç²’å­ï¼');
                    }
                }
            }, 10);
        }
        // å¸å¼•ç²’å­ç³»ç»Ÿ
        let particleCount = 0;
        let positions = new Float32Array(0);
        let velocities = new Float32Array(0);
        let colors = new Float32Array(0);
        let sizes = new Float32Array(0);
        let particles = new THREE.BufferGeometry();
        const particleMaterial = new THREE.PointsMaterial({
            size: 1.0,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        // å¸ç§¯ç›˜
        let innerRingRadius = blackHoleRadius + 1;
        let outerRingRadius = blackHoleRadius + 20;
        let targetInnerRingRadius = innerRingRadius;
        let targetOuterRingRadius = outerRingRadius;
        let ringTransitionActive = false;
        let ringTransitionStartTime = 0;
        const diskGeometry = new THREE.RingGeometry(innerRingRadius, outerRingRadius, 64);
        const diskMaterial = new THREE.MeshBasicMaterial({
            color: holeType === 'black' ? 0xff4500 : 0x00bfff, // orange for black, blue for white
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
        accretionDisk.rotation.x = Math.PI / 2;
        scene.add(accretionDisk);
        function updateAccretionDiskTarget(targetRadius) {
            targetInnerRingRadius = targetRadius + 1;
            const initial = 4;
            const widthScale = targetRadius / initial;
            targetOuterRingRadius = targetRadius + 20 * widthScale;
            ringTransitionActive = true;
            ringTransitionStartTime = Date.now();
            diskMaterial.color.setHex(holeType === 'black' ? 0xff4500 : 0x00bfff);
        }
        // äº‹ä»¶è§†ç•Œ
        let targetHoleRadius = blackHoleRadius;
        let holeTransitionActive = false;
        let holeTransitionStartTime = 0;
        const holeGeometry = new THREE.SphereGeometry(blackHoleRadius, 32, 32);
        const holeMaterial = new THREE.MeshBasicMaterial({ color: holeType === 'black' ? 0x000000 : 0xffffff }); // black for black hole, white for white hole
        const holeMesh = new THREE.Mesh(holeGeometry, holeMaterial);
        scene.add(holeMesh);
        // æˆé•¿/å–·å‡ºå‡½æ•°
        let growthIncrement = config.growthSize * 0.1;
        function growHole() {
            const oldRadius = blackHoleRadius;
            targetHoleRadius = blackHoleRadius + (holeType === 'black' ? growthIncrement : config.ejectionSize * 0.1);
            forceStrength += (holeType === 'black' ? config.gravityInc : config.repulsionInc) * 0.01;
            holeTransitionActive = true;
            holeTransitionStartTime = Date.now();
            updateAccretionDiskTarget(targetHoleRadius);
            updateOrbitTargets(oldRadius, targetHoleRadius);
            addToOrbit();
            startGrowthAnimation();
        }
        // æˆé•¿åŠ¨ç”»
        let growthAnimationActive = false;
        let growthTimer = 0;
        let growthParticles = null;
        let growthVelocities = null;
        let growthMaterial = null;
        let growthPositionsArray = [];
        let growthCount = config.growthNum;
        function startGrowthAnimation() {
            if (growthAnimationActive) return;
            growthAnimationActive = true;
            growthTimer = 0;
            growthPositionsArray = [];
            growthCount = holeType === 'black' ? config.growthNum : config.ejectionNum;
            const growthGeometry = new THREE.BufferGeometry();
            const growthPositions = new Float32Array(growthCount * 3);
            const growthColors = new Float32Array(growthCount * 3);
            growthVelocities = new Float32Array(growthCount * 3);
            for (let i = 0; i < growthCount; i++) {
                growthPositions[i * 3] = (Math.random() - 0.5) * 0.5;
                growthPositions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                growthPositions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
                growthPositionsArray.push(new THREE.Vector3(growthPositions[i * 3], growthPositions[i * 3 + 1], growthPositions[i * 3 + 2]));
                // é¢œè‰²: white for black hole growth, blue for white hole ejection
                const colorHSL = holeType === 'black' ? 0 : 0.55; // white vs blue
                const color = new THREE.Color().setHSL(colorHSL, 1, 1);
                growthColors[i * 3] = color.r;
                growthColors[i * 3 + 1] = color.g;
                growthColors[i * 3 + 2] = color.b;
                const speed = 1.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                growthVelocities[i * 3] = speed * Math.sin(phi) * Math.cos(theta);
                growthVelocities[i * 3 + 1] = speed * Math.sin(phi) * Math.sin(theta);
                growthVelocities[i * 3 + 2] = speed * Math.cos(phi);
            }
            growthGeometry.setAttribute('position', new THREE.BufferAttribute(growthPositions, 3));
            growthGeometry.setAttribute('color', new THREE.BufferAttribute(growthColors, 3));
            growthMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            growthParticles = new THREE.Points(growthGeometry, growthMaterial);
            scene.add(growthParticles);
        }
        let forceStrength = 0.1; // gravity or repulsion
        let absorbedEjectedCount = 0;
        let currentTarget = 10;
        let countSinceLastUpgrade = 0;
        let pushFrameCounter = 0;
        let pushForceVal = config.pushForce * 1.0;
        camera.position.z = 150;
        let time = 0;
        let mouse = new THREE.Vector2();
        // ç‚¹å‡»ç”Ÿæˆç²’å­
        const raycaster = new THREE.Raycaster();
        const generateParticleAtClick = (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const dir = raycaster.ray.direction.clone();
            for (let k = 0; k < clickParticleCount; k++) {
                const scalar = 80 + (k * 20);
                const newPos = new THREE.Vector3().copy(camera.position).add(dir.multiplyScalar(scalar));
                particleCount++;
                const newPositions = new Float32Array(particleCount * 3);
                const newVelocities = new Float32Array(particleCount * 3);
                const newColors = new Float32Array(particleCount * 3);
                const newSizes = new Float32Array(particleCount);
                newPositions.set(positions);
                newVelocities.set(velocities);
                newColors.set(colors);
                newSizes.set(sizes);
                const idx = (particleCount - 1) * 3;
                newPositions[idx] = newPos.x;
                newPositions[idx + 1] = newPos.y;
                newPositions[idx + 2] = newPos.z;
                newVelocities[idx] = (Math.random() - 0.5) * 0.1;
                newVelocities[idx + 1] = (Math.random() - 0.5) * 0.1;
                newVelocities[idx + 2] = (Math.random() - 0.5) * 0.1;
                const radius = Math.sqrt(newPos.x**2 + newPos.y**2 + newPos.z**2);
                const tang_speed = 0.8 * Math.sqrt(forceStrength / radius);
                let perp_x = -newPos.y;
                let perp_y = newPos.x;
                let perp_z = 0;
                const perp_len = Math.sqrt(perp_x * perp_x + perp_y * perp_y);
                if (perp_len > 0.001) {
                    perp_x /= perp_len;
                    perp_y /= perp_len;
                }
                newVelocities[idx] += tang_speed * perp_x;
                newVelocities[idx + 1] += tang_speed * perp_y;
                newVelocities[idx + 2] += (Math.random() - 0.5) * tang_speed * 0.2;
                if (holeType === 'white') {
                    // outward for white hole
                    const outward = 0.5;
                    newVelocities[idx] += (newPos.x / radius) * outward;
                    newVelocities[idx + 1] += (newPos.y / radius) * outward;
                    newVelocities[idx + 2] += (newPos.z / radius) * outward;
                }
                const newColor = new THREE.Color().setHSL(holeType === 'black' ? 0.6 : 0.55, 0.8, 0.5 + Math.random() * 0.3);
                newColors[idx] = newColor.r;
                newColors[idx + 1] = newColor.g;
                newColors[idx + 2] = newColor.b;
                newSizes[particleCount - 1] = 0.3 + Math.random() * 0.4;
                positions = newPositions;
                velocities = newVelocities;
                colors = newColors;
                sizes = newSizes;
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.color.needsUpdate = true;
                particleSystem.geometry.attributes.size.needsUpdate = true;
            }
        };
        renderer.domElement.addEventListener('click', generateParticleAtClick);
        // é…ç½®é¢æ¿
        function openConfig() {
            document.getElementById('configPanel').style.display = 'flex';
            document.getElementById('configTitle').textContent = (holeType === 'black' ? 'é»‘æ´' : 'ç™½æ´') + 'é…ç½®';
            document.getElementById('blackHoleParams').style.display = holeType === 'black' ? 'block' : 'none';
            document.getElementById('whiteHoleParams').style.display = holeType === 'white' ? 'block' : 'none';
            // è®¾ç½®placeholder
            if (holeType === 'black') {
                document.getElementById('growthSize').placeholder = config.growthSize;
                document.getElementById('gravityInc').placeholder = config.gravityInc;
                document.getElementById('initialCount').placeholder = config.initialParticleCount;
                document.getElementById('pushForce').placeholder = config.pushForce;
                document.getElementById('growthNum').placeholder = config.growthNum;
            } else {
                document.getElementById('ejectionSize').placeholder = config.ejectionSize;
                document.getElementById('repulsionInc').placeholder = config.repulsionInc;
                document.getElementById('initialEjectionCount').placeholder = config.initialEjectionCount;
                document.getElementById('pushForceWhite').placeholder = config.pushForceWhite;
                document.getElementById('ejectionNum').placeholder = config.ejectionNum;
            }
        }
        function closeConfig() {
            document.getElementById('configPanel').style.display = 'none';
        }
        // æ¶ˆæ¯
        function showMessage(text) {
            document.getElementById('messageText').textContent = text;
            document.getElementById('messageModal').style.display = 'flex';
        }
        function closeMessage() {
            document.getElementById('messageModal').style.display = 'none';
        }
        // ç¡®è®¤
        function showConfirm(title, message, onYes) {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmText').textContent = message;
            window.currentOnYes = onYes;
            document.getElementById('confirmModal').style.display = 'flex';
        }
        function closeConfirm() {
            document.getElementById('confirmModal').style.display = 'none';
        }
        function confirmSwitch() {
            closeConfirm();
            window.currentOnYes();
        }
        // åˆ‡æ¢æ´ç±»å‹
        function toggleHoleType() {
            const newType = holeType === 'black' ? 'white' : 'black';
            const title = `ç¡®è®¤åˆ‡æ¢åˆ°${newType === 'black' ? 'é»‘æ´' : 'ç™½æ´'}ï¼Ÿ`;
            const message = 'è¿™å°†é‡ç½®å½“å‰æ¨¡æ‹Ÿå¹¶æ¸…ç†æ‰€æœ‰æ•ˆæœã€‚';
            showConfirm(title, message, () => switchHoleType(newType));
        }
        function switchHoleType(newType) {
            // æ¸…ç†
            if (growthAnimationActive) {
                scene.remove(growthParticles);
                if (growthParticles) {
                    growthParticles.geometry.dispose();
                    growthParticles.material.dispose();
                }
                growthAnimationActive = false;
                growthTimer = 0;
                growthPositionsArray = [];
                growthParticles = null;
                growthVelocities = null;
                growthMaterial = null;
            }
            if (ejectAnimationActive) {
                scene.remove(ejectParticles);
                if (ejectParticles) {
                    ejectParticles.geometry.dispose();
                    ejectParticles.material.dispose();
                }
                ejectAnimationActive = false;
                ejectTimer = 0;
                ejectParticles = null;
                ejectVelocities = null;
                ejectMaterial = null;
                ejectCount = 0;
            }
            particleSystem.geometry.dispose();
            scene.remove(particleSystem);
            particles.dispose();
            // é‡ç½®çŠ¶æ€
            holeType = newType;
            blackHoleRadius = 4;
            forceStrength = 0.1;
            countSinceLastUpgrade = 0;
            currentTarget = 10;
            absorbedEjectedCount = 0;
            orbitTransitionActive = false;
            ringTransitionActive = false;
            holeTransitionActive = false;
            // æ›´æ–°UI
            document.getElementById('toggleHoleBtn').textContent = holeType === 'black' ? 'ç™½' : 'é»‘';
            holeMaterial.color.setHex(holeType === 'black' ? 0x000000 : 0xffffff);
            diskMaterial.color.setHex(holeType === 'black' ? 0xff4500 : 0x00bfff);
            initOrbit();
            // é‡æ–°åˆå§‹åŒ–ç²’å­
            const count = holeType === 'black' ? config.initialParticleCount : config.initialEjectionCount;
            initParticles(count, false);
            scene.add(particleSystem);
            // é‡ç½®ç›˜å’Œè§†ç•Œ
            innerRingRadius = 5;
            outerRingRadius = 24;
            targetInnerRingRadius = 5;
            targetOuterRingRadius = 24;
            accretionDisk.geometry.dispose();
            accretionDisk.geometry = new THREE.RingGeometry(5, 24, 64);
            holeMesh.scale.set(1, 1, 1);
        }
        // é‡ç½®æ´
        function resetHole() {
            blackHoleRadius = 4;
            targetHoleRadius = 4;
            holeMesh.scale.set(1, 1, 1);
            forceStrength = 0.1;
            innerRingRadius = 5;
            outerRingRadius = 24;
            targetInnerRingRadius = 5;
            targetOuterRingRadius = 24;
            accretionDisk.geometry.dispose();
            accretionDisk.geometry = new THREE.RingGeometry(5, 24, 64);
            initOrbit();
            orbitTransitionActive = false;
            ringTransitionActive = false;
            holeTransitionActive = false;
        }
        function applyConfig() {
            let valid = true;
            if (holeType === 'black') {
                const growthSize = parseInt(document.getElementById('growthSize').value) || config.growthSize;
                const gravityInc = parseInt(document.getElementById('gravityInc').value) || config.gravityInc;
                const initialCount = parseInt(document.getElementById('initialCount').value) || config.initialParticleCount;
                const pushForce = parseInt(document.getElementById('pushForce').value) || config.pushForce;
                const growthNum = parseInt(document.getElementById('growthNum').value) || config.growthNum;
                if (growthSize < 0 || gravityInc < 0 || initialCount < 0 || pushForce < 0 || growthNum < 0 || isNaN(growthSize) || isNaN(gravityInc) || isNaN(initialCount) || isNaN(pushForce) || isNaN(growthNum)) {
                    valid = false;
                } else {
                    config = { ...config, growthSize, gravityInc, initialParticleCount: initialCount, pushForce, growthNum };
                    growthIncrement = config.growthSize * 0.1;
                    pushForceVal = config.pushForce * 1.0;
                    growthCount = config.growthNum;
                }
            } else {
                const ejectionSize = parseInt(document.getElementById('ejectionSize').value) || config.ejectionSize;
                const repulsionInc = parseInt(document.getElementById('repulsionInc').value) || config.repulsionInc;
                const initialEjectionCount = parseInt(document.getElementById('initialEjectionCount').value) || config.initialEjectionCount;
                const pushForceWhite = parseInt(document.getElementById('pushForceWhite').value) || config.pushForceWhite;
                const ejectionNum = parseInt(document.getElementById('ejectionNum').value) || config.ejectionNum;
                if (ejectionSize < 0 || repulsionInc < 0 || initialEjectionCount < 0 || pushForceWhite < 0 || ejectionNum < 0 || isNaN(ejectionSize) || isNaN(repulsionInc) || isNaN(initialEjectionCount) || isNaN(pushForceWhite) || isNaN(ejectionNum)) {
                    valid = false;
                } else {
                    config = { ...config, ejectionSize, repulsionInc, initialEjectionCount, pushForceWhite, ejectionNum };
                    growthIncrement = config.ejectionSize * 0.1; // reuse for ejection
                    pushForceVal = config.pushForceWhite * 1.0;
                    growthCount = config.ejectionNum;
                }
            }
            if (!valid) {
                showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„éè´Ÿæ•´æ•°ï¼');
                return;
            }
            document.getElementById('loadingScreen').style.display = 'flex';
            const count = holeType === 'black' ? config.initialParticleCount : config.initialEjectionCount;
            initParticles(count, true);
            countSinceLastUpgrade = 0;
            currentTarget = 10;
            absorbedEjectedCount = 0;
            resetHole();
            closeConfig();
        }
        document.getElementById('configBtn').addEventListener('click', openConfig);
        document.getElementById('toggleHoleBtn').addEventListener('click', toggleHoleType);
        // æ¸¸æˆä¿¡æ¯
        function openGameInfo() {
            document.getElementById('gameInfoPanel').style.display = 'flex';
        }
        function closeGameInfo() {
            document.getElementById('gameInfoPanel').style.display = 'none';
        }
        document.getElementById('infoBtn').addEventListener('click', openGameInfo);
        window.addEventListener('click', (event) => {
            const configPanel = document.getElementById('configPanel');
            const gameInfoPanel = document.getElementById('gameInfoPanel');
            const messageModal = document.getElementById('messageModal');
            const confirmModal = document.getElementById('confirmModal');
            if (event.target === configPanel) closeConfig();
            if (event.target === gameInfoPanel) closeGameInfo();
            if (event.target === messageModal) closeMessage();
            if (event.target === confirmModal) closeConfirm();
        });
        // ç§»åŠ¨ç«¯
        function isMobile() {
            return /Mobi|Android/i.test(navigator.userAgent);
        }
        if (isMobile()) {
            document.getElementById('info').textContent = 'å•æŒ‡æ—‹è½¬è§†è§’ åŒæŒ‡å¯ä»¥ç¼©æ”¾/ç§»åŠ¨è§†è§’';
        }
        // åˆå§‹
        initParticles(initialParticleCount, false);
        document.getElementById('toggleHoleBtn').textContent = 'ç™½';
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            const posAttr = particles.getAttribute('position');
            if (!posAttr) {
                controls.update();
                renderer.render(scene, camera);
                return;
            }
            checkAndEjectIfDense();
            // ç”©é£
            if (ejectAnimationActive && ejectParticles && ejectParticles.geometry) {
                ejectTimer++;
                const ejectPosAttr = ejectParticles.geometry.getAttribute('position');
                if (ejectPosAttr) {
                    for (let i = 0; i < ejectCount; i++) {
                        let x = ejectPosAttr.getX(i);
                        let y = ejectPosAttr.getY(i);
                        let z = ejectPosAttr.getZ(i);
                        if (isNaN(x)) x = 0;
                        if (isNaN(y)) y = 0;
                        if (isNaN(z)) z = 0;
                        if (isNaN(ejectVelocities[i * 3])) ejectVelocities[i * 3] = 0;
                        if (isNaN(ejectVelocities[i * 3 + 1])) ejectVelocities[i * 3 + 1] = 0;
                        if (isNaN(ejectVelocities[i * 3 + 2])) ejectVelocities[i * 3 + 2] = 0;
                        x += ejectVelocities[i * 3] * 0.4;
                        y += ejectVelocities[i * 3 + 1] * 0.4;
                        z += ejectVelocities[i * 3 + 2] * 0.4;
                        ejectPosAttr.setXYZ(i, x, y, z);
                    }
                    ejectPosAttr.needsUpdate = true;
                }
                if (ejectTimer > 300) {
                    const fadeProgress = (ejectTimer - 300) / 300;
                    ejectMaterial.opacity = Math.max(0, 1 - fadeProgress);
                    ejectMaterial.needsUpdate = true;
                }
                if (ejectTimer > 600) {
                    scene.remove(ejectParticles);
                    ejectParticles.geometry.dispose();
                    ejectParticles.material.dispose();
                    ejectAnimationActive = false;
                }
            }
            // è§†ç•Œè¿‡æ¸¡
            if (holeTransitionActive) {
                const elapsed = (Date.now() - holeTransitionStartTime) / 1000;
                let progress = elapsed / 1;
                if (progress > 1) progress = 1;
                const currentRadius = blackHoleRadius + (targetHoleRadius - blackHoleRadius) * progress;
                holeMesh.scale.set(currentRadius / 4, currentRadius / 4, currentRadius / 4);
                if (progress >= 1) {
                    blackHoleRadius = targetHoleRadius;
                    holeTransitionActive = false;
                }
            }
            // ç›˜è¿‡æ¸¡
            if (ringTransitionActive) {
                const elapsed = (Date.now() - ringTransitionStartTime) / 1000;
                let progress = elapsed / 1;
                if (progress > 1) progress = 1;
                const currentInner = innerRingRadius + (targetInnerRingRadius - innerRingRadius) * progress;
                const currentOuter = outerRingRadius + (targetOuterRingRadius - outerRingRadius) * progress;
                accretionDisk.geometry.dispose();
                accretionDisk.geometry = new THREE.RingGeometry(currentInner, currentOuter, 64);
                if (progress >= 1) {
                    innerRingRadius = targetInnerRingRadius;
                    outerRingRadius = targetOuterRingRadius;
                    ringTransitionActive = false;
                }
            }
            // ç¯ç»•æ—‹è½¬
            const orbitPosAttr = orbitGeometry.getAttribute('position');
            if (orbitTransitionActive) {
                const elapsed = (Date.now() - orbitTransitionStartTime) / 1000;
                let progress = elapsed / 1;
                if (progress > 1) progress = 1;
                for (let i = 0; i < orbitCount; i++) {
                    let currentR = orbitRadii[i] + (targetOrbitRadii[i] - orbitRadii[i]) * progress;
                    orbitAngles[i] += 0.01 / currentR;
                    orbitPosAttr.setXYZ(i, currentR * Math.cos(orbitAngles[i]), 0, currentR * Math.sin(orbitAngles[i]));
                    if (progress >= 1) orbitRadii[i] = targetOrbitRadii[i];
                }
                if (progress >= 1) orbitTransitionActive = false;
            } else {
                for (let i = 0; i < orbitCount; i++) {
                    const currentR = orbitRadii[i];
                    orbitAngles[i] += 0.01 / currentR;
                    orbitPosAttr.setXYZ(i, currentR * Math.cos(orbitAngles[i]), 0, currentR * Math.sin(orbitAngles[i]));
                }
            }
            orbitPosAttr.needsUpdate = true;
            // æˆé•¿åŠ¨ç”»
            if (growthAnimationActive && growthParticles && growthParticles.geometry) {
                growthTimer++;
                const growthPosAttr = growthParticles.geometry.getAttribute('position');
                if (growthPosAttr) {
                    for (let i = 0; i < growthCount; i++) {
                        let x = growthPosAttr.getX(i);
                        let y = growthPosAttr.getY(i);
                        let z = growthPosAttr.getZ(i);
                        x += growthVelocities[i * 3] * 0.3;
                        y += growthVelocities[i * 3 + 1] * 0.3;
                        z += growthVelocities[i * 3 + 2] * 0.3;
                        growthPosAttr.setXYZ(i, x, y, z);
                        growthPositionsArray[i].set(x, y, z);
                    }
                    growthPosAttr.needsUpdate = true;
                }
                if (growthTimer > 300) {
                    const fadeProgress = (growthTimer - 300) / 300;
                    growthMaterial.opacity = Math.max(0, 1 - fadeProgress);
                    growthMaterial.needsUpdate = true;
                }
                if (growthTimer > 600) {
                    scene.remove(growthParticles);
                    growthParticles.geometry.dispose();
                    growthParticles.material.dispose();
                    growthAnimationActive = false;
                    growthPositionsArray = [];
                }
            }
            // æ›´æ–°ç²’å­
            const colorAttr = particles.getAttribute('color');
            const sizeAttr = particles.getAttribute('size');
            pushFrameCounter++;
            for (let i = 0; i < particleCount; i++) {
                let x = posAttr.getX(i);
                let y = posAttr.getY(i);
                let z = posAttr.getZ(i);
                let dist = Math.sqrt(x * x + y * y + z * z);
                let vx = velocities[i * 3];
                let vy = velocities[i * 3 + 1];
                let vz = velocities[i * 3 + 2];
                if (dist > 0.1) {
                    let accel_mag = forceStrength / (dist * dist);
                    const sign = holeType === 'black' ? -1 : 1; // attract or repel
                    vx += sign * (x / dist) * accel_mag;
                    vy += sign * (y / dist) * accel_mag;
                    vz += sign * (z / dist) * accel_mag;
                    // ç›¸å¯¹è®ºä¿®æ­£ (simplified)
                    let lx = y * vz - z * vy;
                    let ly = z * vx - x * vz;
                    let lz = x * vy - y * vx;
                    let h2 = lx * lx + ly * ly + lz * lz;
                    let rel_accel_mag = 1.5 * h2 / Math.pow(dist, 5);
                    vx += sign * x * rel_accel_mag;
                    vy += sign * y * rel_accel_mag;
                    vz += sign * z * rel_accel_mag;
                    // æ¥è¿‘æ—¶åŠ å¼º
                    if (dist < 20) {
                        accel_mag *= 2.0;
                        vx += sign * (x / dist) * accel_mag;
                        vy += sign * (y / dist) * accel_mag;
                        vz += sign * (z / dist) * accel_mag;
                    }
                    velocities[i * 3] = vx;
                    velocities[i * 3 + 1] = vy;
                    velocities[i * 3 + 2] = vz;
                    // æ¨åŠ¨
                    if (growthAnimationActive && growthTimer < 300 && pushFrameCounter % 5 === 0) {
                        let pushX = 0, pushY = 0, pushZ = 0;
                        let pushCount = 0;
                        for (let j = 0; j < growthPositionsArray.length; j++) {
                            const whitePos = growthPositionsArray[j];
                            const dx = x - whitePos.x;
                            const dy = y - whitePos.y;
                            const dz = z - whitePos.z;
                            const pushDist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                            if (pushDist < 5 && pushDist > 0.1) {
                                const pushForceValLocal = pushForceVal / (pushDist * pushDist);
                                pushX += (dx / pushDist) * pushForceValLocal;
                                pushY += (dy / pushDist) * pushForceValLocal;
                                pushZ += (dz / pushDist) * pushForceValLocal;
                                pushCount++;
                            }
                        }
                        if (pushCount > 0) {
                            velocities[i * 3] += pushX / pushCount;
                            velocities[i * 3 + 1] += pushY / pushCount;
                            velocities[i * 3 + 2] += pushZ / pushCount;
                        }
                    }
                    // æ‰°åŠ¨
                    velocities[i * 3] += (Math.random() - 0.5) * 0.003;
                    velocities[i * 3 + 1] += (Math.random() - 0.5) * 0.003;
                    velocities[i * 3 + 2] += (Math.random() - 0.5) * 0.003;
                    // æ‘©æ“¦
                    velocities[i * 3] *= 0.997;
                    velocities[i * 3 + 1] *= 0.997;
                    velocities[i * 3 + 2] *= 0.997;
                    // æ›´æ–°ä½ç½®
                    x += velocities[i * 3] * 1.2;
                    y += velocities[i * 3 + 1] * 1.2;
                    z += velocities[i * 3 + 2] * 1.2;
                    dist = Math.sqrt(x * x + y * y + z * z);
                    // ç›˜ç¢°æ’
                    const cylR = Math.sqrt(x * x + z * z);
                    let isClose = dist < 20;
                    if (Math.abs(y) < 2 && cylR > blackHoleRadius + 1 && cylR < blackHoleRadius + 20) {
                        if (!isClose || Math.random() > 0.5) {
                            addToOrbit();
                            countSinceLastUpgrade++;
                            absorbedEjectedCount++;
                            if (countSinceLastUpgrade >= currentTarget) {
                                growHole();
                                countSinceLastUpgrade = 0;
                                currentTarget *= 2;
                            }
                            // é‡ç½®åˆ°å¤–å›´
                            const radius = 80 + Math.random() * 150;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(2 * Math.random() - 1);
                            x = radius * Math.sin(phi) * Math.cos(theta);
                            y = radius * Math.sin(phi) * Math.sin(theta);
                            z = radius * Math.cos(phi);
                            velocities[i * 3] = (Math.random() - 0.5) * 0.45;
                            velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.45;
                            velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.45;
                            const color = new THREE.Color().setHSL(holeType === 'black' ? 0.6 : 0.55, 0.8, 0.5 + Math.random() * 0.3);
                            colorAttr.setXYZ(i, color.r, color.g, color.b);
                            sizeAttr.setX(i, 0.3 + Math.random() * 0.4);
                        }
                    }
                    if (dist > 200) {
                        const radius = 80 + Math.random() * 150;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        x = radius * Math.sin(phi) * Math.cos(theta);
                        y = radius * Math.sin(phi) * Math.sin(theta);
                        z = radius * Math.cos(phi);
                        velocities[i * 3] = (Math.random() - 0.5) * 0.45;
                        velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.45;
                        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.45;
                    }
                    posAttr.setXYZ(i, x, y, z);
                    // ç§»è‰²
                    if (dist < 20) {
                        const factor = (20 - dist) / 20;
                        if (holeType === 'black') {
                            colorAttr.setXYZ(i, 1.0, 0.2 * factor, 0.0); // red shift
                        } else {
                            colorAttr.setXYZ(i, 0.0, 0.5 * factor, 1.0); // blue shift
                        }
                        sizeAttr.setX(i, sizes[i] * (1 + factor * 2));
                    }
                    // äº‹ä»¶è§†ç•Œ
                    if (dist < blackHoleRadius) {
                        countSinceLastUpgrade++;
                        absorbedEjectedCount++;
                        if (countSinceLastUpgrade >= currentTarget) {
                            growHole();
                            countSinceLastUpgrade = 0;
                            currentTarget *= 2;
                        }
                        // å¯¹äºç™½æ´ï¼Œç²’å­è¢«â€œå–·å‡ºâ€é‡ç½®åˆ°å¤–å›´
                        const radius = 80 + Math.random() * 150;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        posAttr.setXYZ(i, radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
                        velocities[i * 3] = (Math.random() - 0.5) * 0.45;
                        velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.45;
                        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.45;
                        const color = new THREE.Color().setHSL(holeType === 'black' ? 0.6 : 0.55, 0.8, 0.5 + Math.random() * 0.3);
                        colorAttr.setXYZ(i, color.r, color.g, color.b);
                        sizeAttr.setX(i, 0.3 + Math.random() * 0.4);
                    }
                }
            }
            posAttr.needsUpdate = true;
            colorAttr.needsUpdate = true;
            sizeAttr.needsUpdate = true;
            accretionDisk.rotation.z += 0.005;
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        // çª—å£è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
